export CMAESRuntime
export best, num_population, num_offsprings
export init_τ, init_τ_c, init_τ_σ

mutable struct CMAESRuntime{T} <: AbstractRuntime
	C::Diagonal{Float64}
	E::Matrix{Float64}
	W::Matrix{Float64}
	parent::T
	population::Vector{T}
	offspring::Vector{T}
	fitoff::Vector{Float64}
	fitpop::Vector{Float64}
	σ::Float64
	s::Vector{Float64}
	s_σ::Vector{Float64}
end

function CMAESRuntime(N::Int, individual::T, num_population::Integer, num_offsprings::Integer) where T
    @assert num_population < num_offsprings "Offspring population must be larger then parent population"
    parent = copy(individual)
    population = fill(individual, num_population)
    offspring = Array{T}(undef, num_offsprings)
    fitpop = fill(Inf, num_population)
    fitoff = fill(Inf, num_offsprings)
    C = Diagonal{Float64}(I, N)
    s = zeros(N)
    s_σ = zeros(N)
    σ = 1.0
    E = zeros(N, num_offsprings)
    W = zeros(N, num_offsprings)
	CMAESRuntime(C, E, W, parent, population, offspring, fitoff, fitpop, σ, s, s_σ)
end

best(cr::CMAESRuntime) = cr.population[1], cr.fitpop[1]
num_population(cr::CMAESRuntime) = length(cr.population)
num_offsprings(cr::CMAESRuntime) = length(cr.offspring)

init_τ(prob::AbstractOptProblem) = sqrt(ellength(prob))
init_τ_c(prob::AbstractOptProblem) = ellength(prob)^2
init_τ_σ(prob::AbstractOptProblem) = sqrt(ellength(prob))

function cmaes_step!(cr::CMAESRuntime, objective; τ, τ_c, τ_σ)
	C, E, W, population, offspring, fitoff, fitpop = cr.C, cr.E, cr.W, cr.population, cr.offspring, cr.fitoff, cr.fitpop
	N = size(E, 1)
	parent, σ, s, s_σ =  cr.parent, cr.σ, cr.s, cr.s_σ
    SqrtC = (C + C') / 2.0
    try
        SqrtC = cholesky(SqrtC).U
    catch
        println("Break on Cholesky")
		C, E, W, parent, offspring, σ
    end

    # offspring are generated by transforming standard normally distributed random vectors using a transformation matrix
    for i=1:size(E, 2)
        E[:,i] = randn(N)
        W[:,i] = σ * (SqrtC * E[:,i])
        offspring[i] = parent + W[:,i]   # (L1)
    end
    populate!(fitoff, offspring, objective)

    # Select new parent population
	μ = size(fitpop, 2)
    idx = sortperm(fitoff)[1:μ]
    for i in 1:μ
        population[i] = offspring[idx[i]]
        fitpop[i] = fitoff[idx[i]]
    end

    w = vec(mean(view(W, :,idx), dims=2))
    ɛ = vec(mean(view(E, :,idx), dims=2))
    parent += w            #  forming recombinant perent for next generation (L2)
    @. s = (1.0 - 1.0/τ)*s +
        (sqrt(μ/τ * (2.0 - 1.0/τ))/σ)*w      # (L3)
    C = (1.0 - 1.0/τ_c).*C + (s./τ_c)*s'     # (L4)
    @. s_σ = (1.0 - 1.0/τ_σ)*s_σ +
        sqrt(μ/τ_σ*(2.0 - 1.0/τ_σ))*ɛ        # (L5)
    σ = σ*exp(((s_σ'*s_σ)[1] - N)/(2*N*sqrt(N)))                           # (L6)

	cr.parent, cr.σ, cr.s, cr.s_σ = parent, σ, s, s_σ
	cr
end
